// Import jwt for webtokens
const jwt = require('jsonwebtoken')
// Import bcrypt to hash passwords
const bcrypt = require('bcryptjs')
const asynchHandler = require('express-async-handler')
const User = require('../models/userModel.js')


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

// DESCRIPTION - Register a user
// ROUTE - POST /api/users
// ACCESS - Public
const registerUser = asynchHandler( async (req, res) => {

  // Destructure body data from the request body
  const {name, email, password} = req.body
  // Check if the request body contains name, email and password of registering user. If not, throw an error.
  if(!name || !email || !password) {
    res.status(400)
    throw new Error('Please add all fields')
  }
  // Check if user exists byt using the User model and the fineOne method which we pass email from the request body. 
  const userExists = await User.findOne({email})
  // If a user with a same email exists throw an error
  if(userExists) {
    res.status(400)
    throw new Error('User already exists')
  }

  // Hash password
  // We need to generate a salt to hash password. We do this by calling a bcrypt method of genSalt() which takes a number of rounds.
  const salt = await bcrypt.genSalt(10)
  // Hash the password by using the bcrypt method hash which takes two arguments, the password we want to hash from the request body and second the salt we just created. 
  const hashedPassword = await bcrypt.hash(password, salt)

  // Create the user
  const user = await User.create({
    name: name,
    email: email,
    password: hashedPassword
  })

  if(user) {
    res.status(201).json({
      _id: user._id,
      name: user.name,
      email: user.email,
      // we also want to pass back the token generated by generateToken function
      token: generateToken(user._id)
    })
  } else {
    res.status(400)
    throw new Error('Invalid user data')
  }

  res.json({message: 'Register User' })
})

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

// DESCRIPTION - Authenticate/Login a user
// ROUTE - POST /api/users/login
// ACCESS - Public
const loginUser = asynchHandler( async (req, res) => {

  // Deconstrust req.body to grab email and password
  const { email, password } = req.body

  // Check for user by email
  const user = await User.findOne({email})

  // If user is true and comparing the req.body password with the hashed password from db is true too, then...
  if(user && (await bcrypt.compare(password, user.password))) {
    res.json({
      _id: user.id,
      name: user.name,
      email: user.email,
      // we also want to pass back the token generated by generateToken function
      token: generateToken(user._id)
    })
  } else {
    res.status(400)
    throw new Error('Invalid credentials')
  }

})

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

// DESCRIPTION - Get user data
// ROUTE - GET /api/users/me
// ACCESS - Private
const getMe = asynchHandler( async (req, res) => {
  const {_id, name, email} = await User.findById(req.user._id)

  res.status(200).json({
    id:_id,
    name,
    email,
  })
})

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

// Generate JWT Token function wich takes in the user id which we want as the payload
const generateToken = (id) => {
  // return to function jwt and its method sign which takes 3 parameters first, the payload/data we want to put there, second, the secret on env file and third which is an option that tells it expired in 30 days.
  return jwt.sign({id}, process.env.JWT_SECRET, {
    expiresIn: '30d'
  })
}





module.exports = {
  registerUser,
  loginUser,
  getMe,
}